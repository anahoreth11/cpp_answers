# 10.md

10. SFINAE (англ. substitution failure is not an error, «неудавшаяся подстановка — не ошибка») — правило языка C++, связанное с шаблонами и перегрузкой функций. Широко применяется «не по назначению» — для рефлексии при компиляции: в зависимости от свойств типа компиляция идёт по тому или другому пути.

Правило SFINAE гласит: Если не получается рассчитать окончательные типы/значения шаблонных параметров функции, компилятор не выбрасывает ошибку, а ищет другую подходящую перегрузку. Ошибка будет в трёх случаях:

- Не нашлось ни одной подходящей перегрузки.
- Нашлось несколько таких перегрузок, и компилятор не может решить, какую взять.
- Перегрузка нашлась, она оказалась шаблонной, и при инстанцировании шаблона случилась ошибка.

В C++17 добавили конструкцию if constexpr(), несколько снизившую надобность в SFINAE.

В C++20 появилась конструкция explicit (true). С одной стороны, константа в скобках — тоже часть подстановки, и если её не получится рассчитать, это будет неудавшаяся подстановка. С другой — она также снижает надобность в SFINAE. Также снизили надобность в SFINAE концепции.

*Pimpl*
Другие названия: Bridge, Compilation Firewall, Handle/Body
Часто требуется скрыть детали реализации от пользователей или других разработчиков. Для этого в использующимся классе ("Видимый класс") классе делаем поле, в котором будем инкапсулировать в себе детали реализации конкретной платформы (“Скрываемый класс”).

Пример: допустим, нам необходимо написать кроссплатформенное сетевое приложение с использованием сокетов. Для этого нам необходим класс GeneralSocket (“Видимый класс”), 

//GeneralSocket.h
Class UnixSocketImpl;

Class GeneralSocket
{
public:
 GeneralSocket();
 void connect();
private:
 UnixSocketImpl * socket;
}

//GeneralSocket.cxx
#include “UnixSocketImpl.h”

GeneralSocket::GeneralSocket() : socket (new UnixSocketImpl){}

GeneralSocket::~GeneralSocket() {
 delete socket;
 socket = 0;
}

void GeneralSocket::connect() {
 socket->connectImpl();
}

Теперь пользователь не сможет добраться до конкретной реализации, и будет использовать функционал только через интерфейс класса GeneralSocket.

В С++, в случае изменений в классе (даже в закрытых функциях членах) все пользователи данного класса должны быть перекомпилированы. Для избежания подобных зависимостей используется указатель на функции члены, реализацию которых необходимо скрыть. Эта техника получила название Pimpl (Pointer to Implementation – указатель на реализацию). Два основных недостатка заключаются в следующем:
Каждое создание объекта требует динамического выделения памяти для объекта, на который ссылается указатель
Использование нескольких уровней косвенности (как минимум — один) для доступа к членам скрытого объекта

Что можно попробовать скрыть:

- Только скрытые данные-члены
- Все скрытые данные-члены и функции-члены. К сожалению, скрыть виртуальную функцию невозможно, так как она должна быть видима для производных классов. Также в закрытом классе может понадобиться ссылка на открытый класс для использования его функций
- Закрытые и защищенные члены. К сожалению, защищенные члены скрыть нельзя, так как они должны быть доступны производным классам
- Весь класс. Преимущество заключается в том, что закрытому классу не нужен указатель на открытый класс. С другой стороны, мы лишаемся возможностей наследования

ссылки: <https://ru.wikipedia.org/wiki/SFINAE>
        <https://habr.com/ru/post/111602>
