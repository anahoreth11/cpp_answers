
Оглавление: 
* Сравнение vector и list
* Раскрутка стека



## Сравнение vector и list


 Вектор:

* Непрерывная память.
* Предварительно выделяет пространство для будущих элементов, поэтому требуется дополнительное пространство сверх того, что необходимо для самих элементов.
* Для каждого элемента требуется только пространство для самого типа элемента (никаких дополнительных указателей).
* Можно перераспределять память для всего вектора в любое время, когда вы добавляете элемент.
* Вставки в конце являются постоянным, амортизированным временем, но вставки в другом месте являются дорогостоящим O (n).
* Стирания в конце вектора - это постоянное время, но в остальном это O(n).
* Вы можете случайным образом получить доступ к его элементам.
* Итераторы становятся недействительными, если вы добавляете или удаляете элементы в вектор или из него.
* Вы можете легко получить доступ к базовому массиву, если вам нужен массив элементов.

List:

* Несмежная память.
* Нет предварительно выделенной памяти. Затраты памяти для самого списка являются постоянными.
* Каждый элемент требует дополнительного места для узла, который содержит элемент, включая указатели на следующий и предыдущий элементы в списке.
* Никогда не нужно перераспределять память для всего списка только потому, что вы добавляете элемент.
* Вставки и стирания стоят дешево, независимо от того, где в списке они происходят.
* Это дешево - объединять списки с помощью сращивания.
* Вы не можете получить случайный доступ к элементам, поэтому доступ к определенному элементу в списке может быть дорогостоящим.
* Итераторы остаются действительными даже при добавлении или удалении элементов из списка.
* Если вам нужен массив элементов, вам придется создать новый и добавить их все в него, поскольку базового массива нет.


 ## Раскрутка стека

Поиск catch-обработчика для возбужденного исключения происходит следующим образом. Когда выражение throw находится в try-блоке, все ассоциированные с ним предложения catch исследуются с точки зрения того, могут ли они обработать исключение. Если подходящее предложение catch найдено, то исключение обрабатывается. В противном случае поиск продолжается в вызывающей функции. Предположим, что вызов функции, выполнение которой прекратилось в результате исключения, погружен в try-блок; в такой ситуации исследуются все предложения catch, ассоциированные с этим блоком. Если один из них может обработать исключение, то процесс заканчивается. В противном случае переходим к следующей по порядку вызывающей функции. Этот поиск последовательно проводится во всей цепочке вложенных вызовов. Как только будет найдено подходящее предложение, управление передается в соответствующий обработчик.

Процесс, в результате которого программа последовательно покидает составные инструкции и определения функций в поисках предложения catch, способного обработать возникшее исключение, называется раскруткой стека. По мере раскрутки прекращают существование локальные объекты, объявленные в составных инструкциях и определениях функций, из которых произошел выход. C++ гарантирует, что во время описанного процесса вызываются деструкторы локальных объектов классов, хотя они исчезают из-за возбужденного исключения.

